#!/usr/bin/env node

const DEBUG_LABEL = 'hypersource-client'

const minimist = require('minimist')
const debug = require('debug')(DEBUG_LABEL)
const hsurl = require('../')
const pump = require('pump')
const ram = require('random-access-memory')
const pkg = require('../package.json')
const url = require('url')

const { DEBUG = '' } = process.env

const argv = minimist(process.argv.slice(2), {
  string: [
    'encoding',
    'utf8',
    'input',
    'output',
    'type',
    'key',
  ],

  boolean: [
    'stdout',
    'version',
    'debug',
    'help',
  ],

  alias: {
    input: 'i',
    output: 'o',
    type: 't',
    version: 'V',
    debug: 'D',
    help: 'h',
  },

  default: {
    type: 'hypercore',
    encoding: 'binary',
  }
})

const usage = `usage: hsurl [-hDV] [options] <endpoint>
where options can be:

  -i, --input     Path to storage for input feed
  -o, --output    Path to storage for output feed
  -k, --key       Public key for storage feed
  -t, --type      The feed type (eg: hypercore|hyperdrive|hypertrie...) (Default: 'hypercore')
  -h, --help      Show this message
  -D, --debug     Enable debug output (DEBUG="${DEBUG_LABEL}")
  -V, --version   Show program version
      --stdin     Read request from stdin
      --stdout    Output response to stdout
      --encoding  Set input encoding (--stdout) (Default: 'binary')
      --utf8      Alias for '--enoding=utf8'
`

// enable 'debug()' if given from the command line are inferred from
// the `DEBUG' environment variable
if (argv.debug || /[^|,]?(hsurl)[,|$]?/.test(DEBUG)) {
  require('debug').enable(`${DEBUG},${DEBUG_LABEL}`)
  debug('Debug output is enabled')
}

if (argv.help) {
  console.log(usage)
  process.exit(0)
}

if (argv.version) {
  console.log(pkg.version)
  process.exit(0)
}

if (!argv.input) {
  argv.input = ram
}

if (!argv.output) {
  argv.output = ram
}

if (argv.utf8) {
  argv.encoding = 'utf8'
}

try {
  const { protocol, pathname } = url.parse(argv.input)
  if ('dat:' === protocol && 64 === pathname.length) {
    argv.type = 'hyperdrive'
  }
} catch (err) {
  debug(err)
}

const [ endpoint ] = argv._
const input = require(argv.type)(argv.input, argv.key, argv)
let client = null

if ('function' === typeof input.ready) {
  input.ready(onready)
} else {
  input.on('ready', onready)
}

function update(hyper, cb) {
  switch (argv.type) {
    case 'hypercore': return hyper.update(cb)
    case 'hypertrie': return hyper.feed.update(cb)
    case 'hyperdb': return process.nextTick(cb)
  }

  if ('function' === typeof hyper.update) {
    return hyper.update(cb)
  }

  if ('function' === typeof hyper.feed.update) {
    return hyper.feed.update(cb)
  }

  return hyper.on('update', cb)
}

function sync(hyper, cb) {
  switch (argv.type) {
    case 'hypercore': return hyper.on('sync', cb)
    case 'hypertrie': return hyper.feed.on('sync', cb)
    case 'hyperdb': return process.nextTick(cb)
  }

  return hyper.on('sync', cb)
}

function onready() {
  if ('hypercore' === argv.type) {
    if (true !== process.stdin.isTTY || argv._.includes('-')) {
      process.stdin.setEncoding(argv.encoding)
      process.stdin.pipe(input.createWriteStream({ live: true }))
    }
  }

  client = hsurl(input, endpoint)
  client.connect(onconnect)
}

function onconnect(err, res, req, socket) {
  let output = null

  if (err) {
    console.error('error:', err.message)
    debug(err)
    client.close()
    return process.nextTick(process.exit, 1)
  }

  client.once('close', onclose)

  update(res, onupdate)

  function onclose() {
    process.exit(0)
  }

  function onupdate() {
    output = require(argv.type)(argv.output, res.key)
    replicate(res, output, onreplicate)
    sync(output, onsync)
  }

  function onreplicate(err) {
    if (err) {
      console.error('error:', err.message)
      debug(err)
      client.close()
      return process.nextTick(process.exit, 1)
    }

 }

  function onsync() {
    if ('hypercore' === argv.type) {
      if (true !== process.stdout.isTTY || argv.stdout) {
        const stream = output.createReadStream()
        stream.pipe(process.stdout)
        stream.once('end', () => client.close())
        return
      }
    }

    client.close()
  }
}

function replicate(src, dst, cb) {
  const alice = src.replicate()
  const bob = dst.replicate()
  return pump(alice, bob, alice, cb)
}
